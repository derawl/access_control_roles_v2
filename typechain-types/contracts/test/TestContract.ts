/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace TestContract {
  export type DynamicTupleStruct = {
    a: PromiseOrValue<BigNumberish>;
    b: PromiseOrValue<BytesLike>;
  };

  export type DynamicTupleStructOutput = [BigNumber, string] & {
    a: BigNumber;
    b: string;
  };

  export type StaticTupleStruct = {
    a: PromiseOrValue<BigNumberish>;
    b: PromiseOrValue<boolean>;
  };

  export type StaticTupleStructOutput = [BigNumber, boolean] & {
    a: BigNumber;
    b: boolean;
  };

  export type DynamicNestedTupleStruct = {
    a: PromiseOrValue<BigNumberish>;
    b: TestContract.DynamicTupleStruct;
  };

  export type DynamicNestedTupleStructOutput = [
    BigNumber,
    TestContract.DynamicTupleStructOutput
  ] & { a: BigNumber; b: TestContract.DynamicTupleStructOutput };

  export type StaticNestedTupleStruct = {
    a: PromiseOrValue<BigNumberish>;
    b: TestContract.StaticTupleStruct;
  };

  export type StaticNestedTupleStructOutput = [
    BigNumber,
    TestContract.StaticTupleStructOutput
  ] & { a: BigNumber; b: TestContract.StaticTupleStructOutput };
}

export interface TestContractInterface extends utils.Interface {
  functions: {
    "aStorageNumber()": FunctionFragment;
    "doEvenLess()": FunctionFragment;
    "doNothing()": FunctionFragment;
    "dynamic(bytes)": FunctionFragment;
    "dynamic32(bytes4[])": FunctionFragment;
    "dynamicDynamic32(string,bytes2[])": FunctionFragment;
    "dynamicString(string)": FunctionFragment;
    "emitTheSender()": FunctionFragment;
    "fnThatMaybeReverts(uint256,bool)": FunctionFragment;
    "fnThatReverts()": FunctionFragment;
    "fnWithSingleParam(uint256)": FunctionFragment;
    "fnWithThreeParams(uint256,uint256,uint256)": FunctionFragment;
    "fnWithTwoMixedParams(bool,string)": FunctionFragment;
    "fnWithTwoParams(uint256,uint256)": FunctionFragment;
    "mint(address,uint256)": FunctionFragment;
    "oneParamAddress(address)": FunctionFragment;
    "oneParamArrayOfDynamicTuple((uint256,bytes)[])": FunctionFragment;
    "oneParamArrayOfStatic(uint256[])": FunctionFragment;
    "oneParamArrayOfStaticTuple((uint256,bool)[])": FunctionFragment;
    "oneParamBytes(bytes)": FunctionFragment;
    "oneParamBytesSmall(bytes1)": FunctionFragment;
    "oneParamBytesWord(bytes32)": FunctionFragment;
    "oneParamDynamicNestedTuple((uint256,(uint256,bytes)))": FunctionFragment;
    "oneParamDynamicTuple((uint256,bytes))": FunctionFragment;
    "oneParamIntSmall(int8)": FunctionFragment;
    "oneParamIntWord(int256)": FunctionFragment;
    "oneParamStatic(uint256)": FunctionFragment;
    "oneParamStaticNestedTuple((uint256,(uint256,bool)))": FunctionFragment;
    "oneParamStaticTuple((uint256,bool))": FunctionFragment;
    "oneParamString(string)": FunctionFragment;
    "oneParamUintSmall(uint8)": FunctionFragment;
    "oneParamUintWord(uint256)": FunctionFragment;
    "receiveEthAndDoNothing()": FunctionFragment;
    "setAStorageNumber(uint16)": FunctionFragment;
    "spendAndMaybeRevert(uint256,bool)": FunctionFragment;
    "testDynamic(string,uint256,string,bool,uint8,string,string)": FunctionFragment;
    "twoParamsStatic(uint256,uint256)": FunctionFragment;
    "twoParamsStaticTupleStatic((uint256,bool),uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "aStorageNumber"
      | "doEvenLess"
      | "doNothing"
      | "dynamic"
      | "dynamic32"
      | "dynamicDynamic32"
      | "dynamicString"
      | "emitTheSender"
      | "fnThatMaybeReverts"
      | "fnThatReverts"
      | "fnWithSingleParam"
      | "fnWithThreeParams"
      | "fnWithTwoMixedParams"
      | "fnWithTwoParams"
      | "mint"
      | "oneParamAddress"
      | "oneParamArrayOfDynamicTuple"
      | "oneParamArrayOfStatic"
      | "oneParamArrayOfStaticTuple"
      | "oneParamBytes"
      | "oneParamBytesSmall"
      | "oneParamBytesWord"
      | "oneParamDynamicNestedTuple"
      | "oneParamDynamicTuple"
      | "oneParamIntSmall"
      | "oneParamIntWord"
      | "oneParamStatic"
      | "oneParamStaticNestedTuple"
      | "oneParamStaticTuple"
      | "oneParamString"
      | "oneParamUintSmall"
      | "oneParamUintWord"
      | "receiveEthAndDoNothing"
      | "setAStorageNumber"
      | "spendAndMaybeRevert"
      | "testDynamic"
      | "twoParamsStatic"
      | "twoParamsStaticTupleStatic"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "aStorageNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "doEvenLess",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "doNothing", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "dynamic",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "dynamic32",
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "dynamicDynamic32",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "dynamicString",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "emitTheSender",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "fnThatMaybeReverts",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "fnThatReverts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "fnWithSingleParam",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "fnWithThreeParams",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fnWithTwoMixedParams",
    values: [PromiseOrValue<boolean>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "fnWithTwoParams",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamAddress",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamArrayOfDynamicTuple",
    values: [TestContract.DynamicTupleStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamArrayOfStatic",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamArrayOfStaticTuple",
    values: [TestContract.StaticTupleStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamBytes",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamBytesSmall",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamBytesWord",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamDynamicNestedTuple",
    values: [TestContract.DynamicNestedTupleStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamDynamicTuple",
    values: [TestContract.DynamicTupleStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamIntSmall",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamIntWord",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamStatic",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamStaticNestedTuple",
    values: [TestContract.StaticNestedTupleStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamStaticTuple",
    values: [TestContract.StaticTupleStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamString",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamUintSmall",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "oneParamUintWord",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "receiveEthAndDoNothing",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setAStorageNumber",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "spendAndMaybeRevert",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "testDynamic",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "twoParamsStatic",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "twoParamsStaticTupleStatic",
    values: [TestContract.StaticTupleStruct, PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(
    functionFragment: "aStorageNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "doEvenLess", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "doNothing", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "dynamic", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "dynamic32", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "dynamicDynamic32",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dynamicString",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emitTheSender",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fnThatMaybeReverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fnThatReverts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fnWithSingleParam",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fnWithThreeParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fnWithTwoMixedParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fnWithTwoParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "oneParamAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamArrayOfDynamicTuple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamArrayOfStatic",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamArrayOfStaticTuple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamBytes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamBytesSmall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamBytesWord",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamDynamicNestedTuple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamDynamicTuple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamIntSmall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamIntWord",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamStatic",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamStaticNestedTuple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamStaticTuple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamString",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamUintSmall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oneParamUintWord",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "receiveEthAndDoNothing",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAStorageNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "spendAndMaybeRevert",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testDynamic",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "twoParamsStatic",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "twoParamsStaticTupleStatic",
    data: BytesLike
  ): Result;

  events: {
    "DoEvenLess()": EventFragment;
    "DoNothing()": EventFragment;
    "Dynamic(bytes)": EventFragment;
    "Dynamic32(bytes4[])": EventFragment;
    "DynamicDynamic32(string,bytes2[])": EventFragment;
    "EmitTheSender(address)": EventFragment;
    "FnWithSingleParam(uint256)": EventFragment;
    "FnWithThreeParams(uint256,uint256,uint256)": EventFragment;
    "FnWithTwoMixedParams(bool,string)": EventFragment;
    "FnWithTwoParams(uint256,uint256)": EventFragment;
    "Mint(address,uint256)": EventFragment;
    "Receive()": EventFragment;
    "ReceiveEthAndDoNothing(uint256)": EventFragment;
    "ReceiveFallback(uint256)": EventFragment;
    "TestDynamic(string,uint256,string,bool,uint8,string,string)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "DoEvenLess"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DoNothing"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Dynamic"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Dynamic32"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DynamicDynamic32"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EmitTheSender"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FnWithSingleParam"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FnWithThreeParams"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FnWithTwoMixedParams"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FnWithTwoParams"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Mint"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Receive"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReceiveEthAndDoNothing"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReceiveFallback"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TestDynamic"): EventFragment;
}

export interface DoEvenLessEventObject {}
export type DoEvenLessEvent = TypedEvent<[], DoEvenLessEventObject>;

export type DoEvenLessEventFilter = TypedEventFilter<DoEvenLessEvent>;

export interface DoNothingEventObject {}
export type DoNothingEvent = TypedEvent<[], DoNothingEventObject>;

export type DoNothingEventFilter = TypedEventFilter<DoNothingEvent>;

export interface DynamicEventObject {
  arg0: string;
}
export type DynamicEvent = TypedEvent<[string], DynamicEventObject>;

export type DynamicEventFilter = TypedEventFilter<DynamicEvent>;

export interface Dynamic32EventObject {
  arg0: string[];
}
export type Dynamic32Event = TypedEvent<[string[]], Dynamic32EventObject>;

export type Dynamic32EventFilter = TypedEventFilter<Dynamic32Event>;

export interface DynamicDynamic32EventObject {
  arg0: string;
  arg1: string[];
}
export type DynamicDynamic32Event = TypedEvent<
  [string, string[]],
  DynamicDynamic32EventObject
>;

export type DynamicDynamic32EventFilter =
  TypedEventFilter<DynamicDynamic32Event>;

export interface EmitTheSenderEventObject {
  arg0: string;
}
export type EmitTheSenderEvent = TypedEvent<[string], EmitTheSenderEventObject>;

export type EmitTheSenderEventFilter = TypedEventFilter<EmitTheSenderEvent>;

export interface FnWithSingleParamEventObject {
  arg0: BigNumber;
}
export type FnWithSingleParamEvent = TypedEvent<
  [BigNumber],
  FnWithSingleParamEventObject
>;

export type FnWithSingleParamEventFilter =
  TypedEventFilter<FnWithSingleParamEvent>;

export interface FnWithThreeParamsEventObject {
  arg0: BigNumber;
  arg1: BigNumber;
  arg2: BigNumber;
}
export type FnWithThreeParamsEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  FnWithThreeParamsEventObject
>;

export type FnWithThreeParamsEventFilter =
  TypedEventFilter<FnWithThreeParamsEvent>;

export interface FnWithTwoMixedParamsEventObject {
  arg0: boolean;
  arg1: string;
}
export type FnWithTwoMixedParamsEvent = TypedEvent<
  [boolean, string],
  FnWithTwoMixedParamsEventObject
>;

export type FnWithTwoMixedParamsEventFilter =
  TypedEventFilter<FnWithTwoMixedParamsEvent>;

export interface FnWithTwoParamsEventObject {
  arg0: BigNumber;
  arg1: BigNumber;
}
export type FnWithTwoParamsEvent = TypedEvent<
  [BigNumber, BigNumber],
  FnWithTwoParamsEventObject
>;

export type FnWithTwoParamsEventFilter = TypedEventFilter<FnWithTwoParamsEvent>;

export interface MintEventObject {
  to: string;
  amount: BigNumber;
}
export type MintEvent = TypedEvent<[string, BigNumber], MintEventObject>;

export type MintEventFilter = TypedEventFilter<MintEvent>;

export interface ReceiveEventObject {}
export type ReceiveEvent = TypedEvent<[], ReceiveEventObject>;

export type ReceiveEventFilter = TypedEventFilter<ReceiveEvent>;

export interface ReceiveEthAndDoNothingEventObject {
  amount: BigNumber;
}
export type ReceiveEthAndDoNothingEvent = TypedEvent<
  [BigNumber],
  ReceiveEthAndDoNothingEventObject
>;

export type ReceiveEthAndDoNothingEventFilter =
  TypedEventFilter<ReceiveEthAndDoNothingEvent>;

export interface ReceiveFallbackEventObject {
  amount: BigNumber;
}
export type ReceiveFallbackEvent = TypedEvent<
  [BigNumber],
  ReceiveFallbackEventObject
>;

export type ReceiveFallbackEventFilter = TypedEventFilter<ReceiveFallbackEvent>;

export interface TestDynamicEventObject {
  test: string;
  test2: BigNumber;
  test3: string;
  test4: boolean;
  test5: number;
  test6: string;
  test7: string;
}
export type TestDynamicEvent = TypedEvent<
  [string, BigNumber, string, boolean, number, string, string],
  TestDynamicEventObject
>;

export type TestDynamicEventFilter = TypedEventFilter<TestDynamicEvent>;

export interface TestContract extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TestContractInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    aStorageNumber(overrides?: CallOverrides): Promise<[number]>;

    doEvenLess(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    doNothing(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    dynamic(
      first: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    dynamic32(
      first: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    dynamicDynamic32(
      first: PromiseOrValue<string>,
      second: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    dynamicString(
      arg0: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    emitTheSender(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    fnThatMaybeReverts(
      a: PromiseOrValue<BigNumberish>,
      maybe: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    fnThatReverts(overrides?: CallOverrides): Promise<[void]>;

    fnWithSingleParam(
      p: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    fnWithThreeParams(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      c: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    fnWithTwoMixedParams(
      a: PromiseOrValue<boolean>,
      s: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    fnWithTwoParams(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mint(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamAddress(
      arg0: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamArrayOfDynamicTuple(
      arg0: TestContract.DynamicTupleStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamArrayOfStatic(
      arg0: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamArrayOfStaticTuple(
      arg0: TestContract.StaticTupleStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamBytes(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamBytesSmall(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamBytesWord(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamDynamicNestedTuple(
      arg0: TestContract.DynamicNestedTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamDynamicTuple(
      arg0: TestContract.DynamicTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamIntSmall(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamIntWord(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamStatic(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamStaticNestedTuple(
      arg0: TestContract.StaticNestedTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamStaticTuple(
      arg0: TestContract.StaticTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamString(
      arg0: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamUintSmall(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oneParamUintWord(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    receiveEthAndDoNothing(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAStorageNumber(
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    spendAndMaybeRevert(
      arg0: PromiseOrValue<BigNumberish>,
      revert_: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[void]>;

    testDynamic(
      test: PromiseOrValue<string>,
      test2: PromiseOrValue<BigNumberish>,
      test3: PromiseOrValue<string>,
      test4: PromiseOrValue<boolean>,
      test5: PromiseOrValue<BigNumberish>,
      test6: PromiseOrValue<string>,
      test7: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    twoParamsStatic(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    twoParamsStaticTupleStatic(
      arg0: TestContract.StaticTupleStruct,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  aStorageNumber(overrides?: CallOverrides): Promise<number>;

  doEvenLess(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  doNothing(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  dynamic(
    first: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  dynamic32(
    first: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  dynamicDynamic32(
    first: PromiseOrValue<string>,
    second: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  dynamicString(
    arg0: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  emitTheSender(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  fnThatMaybeReverts(
    a: PromiseOrValue<BigNumberish>,
    maybe: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fnThatReverts(overrides?: CallOverrides): Promise<void>;

  fnWithSingleParam(
    p: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  fnWithThreeParams(
    a: PromiseOrValue<BigNumberish>,
    b: PromiseOrValue<BigNumberish>,
    c: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  fnWithTwoMixedParams(
    a: PromiseOrValue<boolean>,
    s: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  fnWithTwoParams(
    a: PromiseOrValue<BigNumberish>,
    b: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mint(
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamAddress(
    arg0: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamArrayOfDynamicTuple(
    arg0: TestContract.DynamicTupleStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamArrayOfStatic(
    arg0: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamArrayOfStaticTuple(
    arg0: TestContract.StaticTupleStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamBytes(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamBytesSmall(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamBytesWord(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamDynamicNestedTuple(
    arg0: TestContract.DynamicNestedTupleStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamDynamicTuple(
    arg0: TestContract.DynamicTupleStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamIntSmall(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamIntWord(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamStatic(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamStaticNestedTuple(
    arg0: TestContract.StaticNestedTupleStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamStaticTuple(
    arg0: TestContract.StaticTupleStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamString(
    arg0: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamUintSmall(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oneParamUintWord(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  receiveEthAndDoNothing(
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAStorageNumber(
    value: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  spendAndMaybeRevert(
    arg0: PromiseOrValue<BigNumberish>,
    revert_: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<void>;

  testDynamic(
    test: PromiseOrValue<string>,
    test2: PromiseOrValue<BigNumberish>,
    test3: PromiseOrValue<string>,
    test4: PromiseOrValue<boolean>,
    test5: PromiseOrValue<BigNumberish>,
    test6: PromiseOrValue<string>,
    test7: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  twoParamsStatic(
    a: PromiseOrValue<BigNumberish>,
    b: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  twoParamsStaticTupleStatic(
    arg0: TestContract.StaticTupleStruct,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    aStorageNumber(overrides?: CallOverrides): Promise<number>;

    doEvenLess(overrides?: CallOverrides): Promise<void>;

    doNothing(overrides?: CallOverrides): Promise<void>;

    dynamic(
      first: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    dynamic32(
      first: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    dynamicDynamic32(
      first: PromiseOrValue<string>,
      second: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    dynamicString(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    emitTheSender(overrides?: CallOverrides): Promise<void>;

    fnThatMaybeReverts(
      a: PromiseOrValue<BigNumberish>,
      maybe: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fnThatReverts(overrides?: CallOverrides): Promise<void>;

    fnWithSingleParam(
      p: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    fnWithThreeParams(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      c: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    fnWithTwoMixedParams(
      a: PromiseOrValue<boolean>,
      s: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    fnWithTwoParams(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    mint(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oneParamAddress(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamArrayOfDynamicTuple(
      arg0: TestContract.DynamicTupleStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamArrayOfStatic(
      arg0: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamArrayOfStaticTuple(
      arg0: TestContract.StaticTupleStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamBytes(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamBytesSmall(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamBytesWord(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamDynamicNestedTuple(
      arg0: TestContract.DynamicNestedTupleStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamDynamicTuple(
      arg0: TestContract.DynamicTupleStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamIntSmall(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamIntWord(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamStatic(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamStaticNestedTuple(
      arg0: TestContract.StaticNestedTupleStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamStaticTuple(
      arg0: TestContract.StaticTupleStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamString(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamUintSmall(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    oneParamUintWord(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    receiveEthAndDoNothing(overrides?: CallOverrides): Promise<void>;

    setAStorageNumber(
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    spendAndMaybeRevert(
      arg0: PromiseOrValue<BigNumberish>,
      revert_: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    testDynamic(
      test: PromiseOrValue<string>,
      test2: PromiseOrValue<BigNumberish>,
      test3: PromiseOrValue<string>,
      test4: PromiseOrValue<boolean>,
      test5: PromiseOrValue<BigNumberish>,
      test6: PromiseOrValue<string>,
      test7: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    twoParamsStatic(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    twoParamsStaticTupleStatic(
      arg0: TestContract.StaticTupleStruct,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "DoEvenLess()"(): DoEvenLessEventFilter;
    DoEvenLess(): DoEvenLessEventFilter;

    "DoNothing()"(): DoNothingEventFilter;
    DoNothing(): DoNothingEventFilter;

    "Dynamic(bytes)"(arg0?: null): DynamicEventFilter;
    Dynamic(arg0?: null): DynamicEventFilter;

    "Dynamic32(bytes4[])"(arg0?: null): Dynamic32EventFilter;
    Dynamic32(arg0?: null): Dynamic32EventFilter;

    "DynamicDynamic32(string,bytes2[])"(
      arg0?: null,
      arg1?: null
    ): DynamicDynamic32EventFilter;
    DynamicDynamic32(arg0?: null, arg1?: null): DynamicDynamic32EventFilter;

    "EmitTheSender(address)"(arg0?: null): EmitTheSenderEventFilter;
    EmitTheSender(arg0?: null): EmitTheSenderEventFilter;

    "FnWithSingleParam(uint256)"(arg0?: null): FnWithSingleParamEventFilter;
    FnWithSingleParam(arg0?: null): FnWithSingleParamEventFilter;

    "FnWithThreeParams(uint256,uint256,uint256)"(
      arg0?: null,
      arg1?: null,
      arg2?: null
    ): FnWithThreeParamsEventFilter;
    FnWithThreeParams(
      arg0?: null,
      arg1?: null,
      arg2?: null
    ): FnWithThreeParamsEventFilter;

    "FnWithTwoMixedParams(bool,string)"(
      arg0?: null,
      arg1?: null
    ): FnWithTwoMixedParamsEventFilter;
    FnWithTwoMixedParams(
      arg0?: null,
      arg1?: null
    ): FnWithTwoMixedParamsEventFilter;

    "FnWithTwoParams(uint256,uint256)"(
      arg0?: null,
      arg1?: null
    ): FnWithTwoParamsEventFilter;
    FnWithTwoParams(arg0?: null, arg1?: null): FnWithTwoParamsEventFilter;

    "Mint(address,uint256)"(to?: null, amount?: null): MintEventFilter;
    Mint(to?: null, amount?: null): MintEventFilter;

    "Receive()"(): ReceiveEventFilter;
    Receive(): ReceiveEventFilter;

    "ReceiveEthAndDoNothing(uint256)"(
      amount?: null
    ): ReceiveEthAndDoNothingEventFilter;
    ReceiveEthAndDoNothing(amount?: null): ReceiveEthAndDoNothingEventFilter;

    "ReceiveFallback(uint256)"(amount?: null): ReceiveFallbackEventFilter;
    ReceiveFallback(amount?: null): ReceiveFallbackEventFilter;

    "TestDynamic(string,uint256,string,bool,uint8,string,string)"(
      test?: null,
      test2?: null,
      test3?: null,
      test4?: null,
      test5?: null,
      test6?: null,
      test7?: null
    ): TestDynamicEventFilter;
    TestDynamic(
      test?: null,
      test2?: null,
      test3?: null,
      test4?: null,
      test5?: null,
      test6?: null,
      test7?: null
    ): TestDynamicEventFilter;
  };

  estimateGas: {
    aStorageNumber(overrides?: CallOverrides): Promise<BigNumber>;

    doEvenLess(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    doNothing(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    dynamic(
      first: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    dynamic32(
      first: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    dynamicDynamic32(
      first: PromiseOrValue<string>,
      second: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    dynamicString(
      arg0: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    emitTheSender(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    fnThatMaybeReverts(
      a: PromiseOrValue<BigNumberish>,
      maybe: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fnThatReverts(overrides?: CallOverrides): Promise<BigNumber>;

    fnWithSingleParam(
      p: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    fnWithThreeParams(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      c: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    fnWithTwoMixedParams(
      a: PromiseOrValue<boolean>,
      s: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    fnWithTwoParams(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mint(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamAddress(
      arg0: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamArrayOfDynamicTuple(
      arg0: TestContract.DynamicTupleStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamArrayOfStatic(
      arg0: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamArrayOfStaticTuple(
      arg0: TestContract.StaticTupleStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamBytes(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamBytesSmall(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamBytesWord(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamDynamicNestedTuple(
      arg0: TestContract.DynamicNestedTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamDynamicTuple(
      arg0: TestContract.DynamicTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamIntSmall(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamIntWord(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamStatic(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamStaticNestedTuple(
      arg0: TestContract.StaticNestedTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamStaticTuple(
      arg0: TestContract.StaticTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamString(
      arg0: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamUintSmall(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oneParamUintWord(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    receiveEthAndDoNothing(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAStorageNumber(
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    spendAndMaybeRevert(
      arg0: PromiseOrValue<BigNumberish>,
      revert_: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    testDynamic(
      test: PromiseOrValue<string>,
      test2: PromiseOrValue<BigNumberish>,
      test3: PromiseOrValue<string>,
      test4: PromiseOrValue<boolean>,
      test5: PromiseOrValue<BigNumberish>,
      test6: PromiseOrValue<string>,
      test7: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    twoParamsStatic(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    twoParamsStaticTupleStatic(
      arg0: TestContract.StaticTupleStruct,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    aStorageNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    doEvenLess(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    doNothing(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    dynamic(
      first: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    dynamic32(
      first: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    dynamicDynamic32(
      first: PromiseOrValue<string>,
      second: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    dynamicString(
      arg0: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    emitTheSender(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    fnThatMaybeReverts(
      a: PromiseOrValue<BigNumberish>,
      maybe: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fnThatReverts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fnWithSingleParam(
      p: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    fnWithThreeParams(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      c: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    fnWithTwoMixedParams(
      a: PromiseOrValue<boolean>,
      s: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    fnWithTwoParams(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mint(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamAddress(
      arg0: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamArrayOfDynamicTuple(
      arg0: TestContract.DynamicTupleStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamArrayOfStatic(
      arg0: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamArrayOfStaticTuple(
      arg0: TestContract.StaticTupleStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamBytes(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamBytesSmall(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamBytesWord(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamDynamicNestedTuple(
      arg0: TestContract.DynamicNestedTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamDynamicTuple(
      arg0: TestContract.DynamicTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamIntSmall(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamIntWord(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamStatic(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamStaticNestedTuple(
      arg0: TestContract.StaticNestedTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamStaticTuple(
      arg0: TestContract.StaticTupleStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamString(
      arg0: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamUintSmall(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oneParamUintWord(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    receiveEthAndDoNothing(
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAStorageNumber(
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    spendAndMaybeRevert(
      arg0: PromiseOrValue<BigNumberish>,
      revert_: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    testDynamic(
      test: PromiseOrValue<string>,
      test2: PromiseOrValue<BigNumberish>,
      test3: PromiseOrValue<string>,
      test4: PromiseOrValue<boolean>,
      test5: PromiseOrValue<BigNumberish>,
      test6: PromiseOrValue<string>,
      test7: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    twoParamsStatic(
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    twoParamsStaticTupleStatic(
      arg0: TestContract.StaticTupleStruct,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
